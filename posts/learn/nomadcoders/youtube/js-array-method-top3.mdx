---
icon: 📘
title: "JavaScript 배열 메서드 TOP3"
date: "2022-06-07"
slug: /nomadcoders/youtube/js-array-method-top3
folder: learn
tags: [""]
---

[https://youtu.be/N7xZRJJ8Thc](https://youtu.be/N7xZRJJ8Thc)

모든 JS 개발자들이 알아야하는 배열의 함수형 메소드 3가지를 소개합니다.

### .find()

배열 내에서 항목을 찾는데 도움을 줍니다.

**사용방법**

```jsx
function findAvocado(currentFruit) {
	return currentFruit === "🥑"
}
const fruits = ["🍎", "🍌", "🍉", "🥑"];
const avocado = fruits**.find**(findAvocado);
```

“`.find`”는 소개할 다른 메소드들과 마찬가지로 필요한 파라미터는 하나뿐이고

그것은 콜백 함수(callback function)입니다.

콜백함수는 우리는 함수의 이름만 적으면 됩니다.

우리가 호출하는 것이 아니라 JS가 함수를 유용한 인수(arguments)와 함께 호출 할 것입니다.

find의 경우 JS는 과일 배열의 각 과일 첫번째 인수와 함께 `findAvocado` 함수를 호출합니다.

즉, JS가 하는 작업은 다음과 같습니다.

```jsx
function findAvocado(currentFruit) {
	return currentFruit === "🥑"
}
const fruits = ["🍎", "🍌", "🍉", "🥑"];
const avocado = fruits.find(
	findAvocado(🍎)
	findAvocado(🍌)
	findAvocado(🍉)
	findAvocado(🥑)
);
```

위 코드는 작동하는 코드는 아니고, 이해하기 쉽게 하기 위해 상상한 것입니다.

콜백함수에 있는 파라미터 이름은 중요하지 않습니다.

“`currentFruit`"이라고 이름을 붙였는데 물론 다른 이름을 붙여도 됩니다.

중요한 것은 ‘위치’입니다.

이제. “`findAvocado`” 함수가 무엇을 하는지 살펴보겠습니다.

각 메서드에는 콜백 함수가 수행하는 작업에 대한 규칙이 있습니다.

**.find의 규칙**

콜백 함수가 “`true`”를 반환하는 경우 찾고 있던 항목을 찾았음을 의미합니다.

“`findAvocado`” 함수에서 ‘`true`’가 되는 조건은

```jsx
function findAvocado(currentFruit) {
  return currentFruit === "🥑";
}
const fruits = ["🍎", "🍌", "🍉", "🥑"];
const avocado = fruits.find(findAvocado);
console.log(avocado); //"🥑"
```

“`currentFruit`”이 ‘`Avocado`’와 같으면 됩니다.

그렇지 않으면. ‘`False`’가 될 것입니다.

“`findAvocado`” 함수가 ‘`true`’를 리턴한 후

처리 중인 현재 항목은 `.find` 함수의 결과 값이 될 것입니다.

이것이 아보카도 변수가 보유하게 될 값입니다.

### .map()

`.map`을 사용하면 배열의 요소를 가져와 변환한 다음

새 배열에 배치할 수 있습니다.

“.map”은 ‘source’ 배열을 수정하지 않고 대신 변환한 값으로 완전히 새로운 배열을 만듭니다.

**사용방법**

```jsx
function double(currentNumber) {
  return currentNumber * 2;
}
const source = [2, 4, 6, 8, 10];
const transformed = source.map(double);
```

`.find`에서 본 것처럼 콜백 함수는 배열의 각 항목에 대해 호출되고.

첫 번째 인수는 현재 처리 중인 항목이 됩니다.

```jsx
function double(currentNumber) {
return currentNumber * 2;
}
const source = [2, 4, 6, 8, 10];
const transformed = source.map(
	double(2)
	double(4)
	double(6)
	double(8)
	double(10)
);
```

이해를 쉽게 하기 위해 위처럼 물론 실제 작동하는 코드는 아니지만 위처럼 상상해봅시다.

이해를 돕기 위한 코드입니다.

**.map의 규칙**

콜백 함수에 의해 반환되는 값이 새 배열에 있는 값이 됩니다.

현재 콜백 함수는 `currentNumber` 인수안에 배열의 각각의 숫자를 받고 있습니다.

그리고 `currentNumber X 2`의 값을 리턴하고 있습니다.

```jsx
function double(currentNumber) {
  return currentNumber * 2;
}
const source = [2, 4, 6, 8, 10];
const transformed = source.map(double);
console.log(transformed); //[4, 8, 12, 16, 20]
```

즉, `.map` 함수가 완료되면 `transformed` 변수의 값은

`source` 배열과 같은 길이지만 숫자는 두 배가 되는 배열이 될 것입니다.

콜백 함수는 뭔가 반드시 리턴해야한다는 걸 기억하세요

```jsx
function double(currentNumber) {
		 	currentNumber * 2;
}
const source = [2, 4, 6, 8, 10];
const transformed = source.map(double);
console.log(transformed); **//[undifined, undifined, undifined, undifined, undifined]**
```

만약 위 코드처럼 리턴해야한다는 걸 까먹는다면 결과 배열이 `undefined`로 가득 차게 될 것 입니다.

### Arrow Function

마지막 메소드들은 새로운 구문을 사용하겠습니다.

함수를 쓰는 새로운 방법인데 바로 화살표 함수(arrow function)를 사용하겠습니다.

```jsx
function double(currentNumber) {
  return currentNumber * 2;
}
const source = [2, 4, 6, 8, 10];
const transformed = source.map(double);

function findAvocado(currentFruit) {
  return currentFruit === "🥑";
}
const fruits = ["🍎", "🍌", "🍉", "🥑"];
const avocado = fruits.find(findAvocado);
```

화살표 함수를 사용하면 `.find` 및 `.map` 예제를

```jsx
const source = [2, 4, 6, 8, 10];
const transformed = source.map((currentNumber) => currentNumber * 2);

const fruits = ["🍎", "🍌", "🍉", "🥑"];
const avocado = fruites.find((currentFruit) => currentFruit === "🥑");
```

위 코드처럼 수정할 수 있습니다.

보다시피 훨씬 개선 된 것을 볼 수 있습니다.

화살표 함수는 함수라는 단어를 쓰고 ()를 쓰고 하는 대신에 코드 한 줄에 함수를 쓸 수 있도록 허용합니다.

딱 한줄의 코드면되고 이해하기도 쉽습니다.

```
arguments ⇒ return-value
```

첫번째 부분에 인수를 쓰고, 화살표 뒤에 값을 반환하면 됩니다.

화살표 함수의 힘은 암묵적 리턴(implicit return)을 가지고 있다는 것입니다.

즉, 반환하기 위해 ‘return’ 키워드가 필요하지 않고

```
=> whatever
```

화살표 뒤에 쓰는 그 어떤 것이든 자동으로 리턴될 것입니다.

```jsx
const avocado = fruits.find(
	findAvocado(🍎)
	findAvocado(🍌)
	findAvocado(🍉)
	findAvocado(🥑)
);
```

화살표 함수 전에는 위처럼 작성되고 있었는데,

```jsx
const avocado = fruits.find(
	(🍎) => 🍎 === "🥑"
	(🍌) => 🍌 === "🥑"
	(🍉) => 🍉 === "🥑"
	(🥑) => 🥑 === "🥑" //true
);
```

화살표 함수 덕분에 위와 같이 작업을 하게 되었습니다.

### .filter()

`.filter`를 사용하면 배열에서 항목을 제거할 수 있습니다.

사실 `.filter`는 `.map` 처럼 ‘source’ 배열을 변형시키지는 않습니다.

`.filter`는 원하지 않는 아이템을 제거한 상태로 완전히 새로운 배열을 만듭니다.

**사용방법**

```jsx
const foods = ["🍎", "🍌", "🌽", "🍉", "🥑"];
const fruits = foods.filter((currentFood) => currentFood !== "🌽");
```

**[ new array ]**

‘true’를 반환하면 항목이 새 배열로 이동하고

‘false’를 반환하면 해당 항목은 새 배열에서 제거됩니다.

과일과 옥수수가 있는 ‘foods’라는 배열 중 과일만 갖은 배열을 만들기 위해서는

콜백 함수에서 `currentFood`가 옥수수인지를 체크하면 됩니다.

```jsx
const foods = ["🍎", "🍌", "🌽", "🍉", "🥑"];
const fruits = foods.filter((currentFood) => currentFood !== "🌽");
console.log(fruits); //['🍎', '🍌', '🍉', '🥑'];
```

옥수수가 아니면, 새 배열로 이동하고

만약 옥수수라면 조건은 ‘false’를 리턴할 것이고 기존 배열에서 옥수수를 제거합니다.

참고로 `.reduce` , `.flat` 및 `.sort`와 같은 다른 유용한 메소드들도 존재합니다.

### ⚡️

`.reduce`

`.flat`

`.sort`
